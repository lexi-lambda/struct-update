#lang scribble/manual

@(require (for-label racket/base
                     racket/contract
                     struct-update)
          scribble/eval)

@(define (reftech . pre-content)
   (apply tech #:doc '(lib "scribblings/reference/reference.scrbl") pre-content))

@(define-syntax-rule (struct-update-eval body ...)
   (examples #:eval ((make-eval-factory '(struct-update)))
             body ...))

@(define-syntax-rule @try-modname[modname]
   (with-handlers ([exn:missing-module? (λ (_) @tt[(symbol->string 'modname)])])
     (dynamic-require 'modname #f)
     @racketmodname[modname]))

@title{Purely Functional Struct Updaters}

@defmodule[struct-update]

Racket encourages programming in a functional style, which in turn encourages immutability. When
manipulating immutable data structures, it is important to be able to @italic{functionally update}
those data structures—that is, copy them with certain values replaced. Racket provides functions like
@racket[hash-set] and @racket[hash-update] for functionally updating data structures, but while the
@racket[struct] form produces immutable structures by default, it does not define any similar updaters
automatically.

This library provides a @racket[define-struct-updaters] form to accomplish that task. For a built-in
solution to the same problem, see @racket[struct-copy]. For a more powerful solution (especially
useful for updating @italic{nested} data structures), consider the @try-modname[lens] library.

@defform[(define-struct-updaters struct-id)]{
@let[([struct-id? @elem{@racket[struct-id]@racketidfont{?}}])]{@list{
Given an identifier bound to a
@seclink["structinfo" #:doc '(lib "scribblings/reference/reference.scrbl")]{structure type transformer
binding}, generates functional setter and updater functions for each field of the struct.

Two functions are generated for each field. Their names are generated by appending @racket[-set] and
@racket[-update] onto each of the accessor functions, and they are unhygienically bound using the
lexical context of @racket[struct-id]. Each setter function is protected by the contract
@racket[(-> #,struct-id? any/c #,struct-id?)], and each updater functions is protected by the contract
@racket[(-> #,struct-id? (-> any/c any/c) #,struct-id?)].

@(struct-update-eval
  (struct point (x y) #:transparent)
  (define-struct-updaters point)
  (point-x-set (point 1 2) 10)
  (point-y-update (point 1 2) add1))

If @racket[struct-id] is a substruct of a parent struct, @racket[_super-id], then it generates setters
and updaters for the super fields as well. These are generated with the names
@racket[struct-id]@racketidfont{-}@racket[_super-id]@racketidfont{-}@racket[_field-id]@racket[-set] and
@racket[struct-id]@racketidfont{-}@racket[_super-id]@racketidfont{-}@racket[_field-id]@racket[-update].
These will functionally update the fields of the parent struct, but they will produce instances of
@racket[struct-id] instead of @racket[_super-id].

@(struct-update-eval
  (struct object (mass position) #:transparent)
  (struct movable object (velocity) #:transparent)
  (define-struct-updaters object)
  (define-struct-updaters movable)
  (object-mass-set (object 5 (list 1 2)) 10)
  (object-mass-set (movable 5 (list 1 2) (list 0 0)) 10)
  (movable-velocity-set (movable 5 (list 1 2) (list 0 0)) (list -3 -4))
  (movable-object-mass-set (movable 5 (list 1 2) (list 0 0)) 10))
}}}

@defform[(struct-updaters-out struct-id)]{
A @reftech{provide transformer} that provides all of the bindings generated by
@racket[define-struct-updaters].}

@defform[(struct+updaters-out struct-id)]{
Like @racket[struct-updaters-out] combined with @racket[struct-out], provides all of a structure
type’s bindings, plus the bindings generated by @racket[define-struct-updaters].}
